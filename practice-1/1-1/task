#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  // <--- добавить для strtok()

// Указываем путь к файлам в Linux
#define INPUT_FILE "/mnt/c/Users/1/Desktop/Системное программирование/practice-1/1-1/input.txt"
#define OUTPUT_FILE "/mnt/c/Users/1/Desktop/Системное программирование/practice-1/1-1/max.txt"
#define NUM_COUNT 50
#define BUFFER_SIZE 1024

void create_input_file() {
    int fd = open(INPUT_FILE, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd < 0) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    char buffer[BUFFER_SIZE];
    int offset = 0;
    for (int i = 1; i <= NUM_COUNT; i++) {
        int len = snprintf(buffer + offset, BUFFER_SIZE - offset, "%d ", i);
        if (len < 0) {
            perror("snprintf");
            close(fd);
            exit(EXIT_FAILURE);
        }
        offset += len;
        if (offset >= BUFFER_SIZE - 20) {
            if (write(fd, buffer, offset) != offset) {
                perror("write");
                close(fd);
                exit(EXIT_FAILURE);
            }
            offset = 0;
        }
    }
    if (offset > 0) {
        if (write(fd, buffer, offset) != offset) {
            perror("write");
            close(fd);
            exit(EXIT_FAILURE);
        }
    }
    close(fd);
}

int find_max_from_file(const char *filename) {
    int fd = open(filename, O_RDONLY);
    if (fd < 0) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    char buffer[BUFFER_SIZE + 1]; // увеличил буфер для безопасного нуль-терминирования
    ssize_t bytes_read;
    int max = 0;
    int first_number = 1;

    while ((bytes_read = read(fd, buffer, BUFFER_SIZE)) > 0) {
        buffer[bytes_read] = '\0'; // завершаем строку безопасно
        char *ptr = buffer;
        // Используем strtok для разделения по пробелам
        char *token = strtok(ptr, " \n");
        while (token != NULL) {
            int num = atoi(token);
            if (first_number || num > max) {
                max = num;
                first_number = 0;
            }
            token = strtok(NULL, " \n");
        }
    }

    if (bytes_read < 0) {
        perror("read");
        close(fd);
        exit(EXIT_FAILURE);
    }

    close(fd);
    return max;
}

void write_max_to_file(int max) {
    int fd = open(OUTPUT_FILE, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd < 0) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    char buffer[50];
    int len = snprintf(buffer, sizeof(buffer), "%d\n", max);
    if (write(fd, buffer, len) != len) {
        perror("write");
        close(fd);
        exit(EXIT_FAILURE);
    }
    close(fd);
}

int main() {
    create_input_file();
    int max_value = find_max_from_file(INPUT_FILE);
    write_max_to_file(max_value);
    return 0;
}
